"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _wrapNativeSuper2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapNativeSuper"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

function _wrapRegExp() { _wrapRegExp = function _wrapRegExp(re, groups) { return new BabelRegExp(re, undefined, groups); }; var _RegExp = (0, _wrapNativeSuper2.default)(RegExp); var _super = RegExp.prototype; var _groups = new WeakMap(); function BabelRegExp(re, flags, groups) { var _this = _RegExp.call(this, re, flags); _groups.set(_this, groups || _groups.get(re)); return _this; } (0, _inherits2.default)(BabelRegExp, _RegExp); BabelRegExp.prototype.exec = function (str) { var result = _super.exec.call(this, str); if (result) result.groups = buildGroups(result, this); return result; }; BabelRegExp.prototype[Symbol.replace] = function (str, substitution) { if (typeof substitution === "string") { var groups = _groups.get(this); return _super[Symbol.replace].call(this, str, substitution.replace(/\$<([^>]+)>/g, function (_, name) { return "$" + groups[name]; })); } else if (typeof substitution === "function") { var _this = this; return _super[Symbol.replace].call(this, str, function () { var args = []; args.push.apply(args, arguments); if (_typeof(args[args.length - 1]) !== "object") { args.push(buildGroups(args, _this)); } return substitution.apply(this, args); }); } else { return _super[Symbol.replace].call(this, str, substitution); } }; function buildGroups(result, re) { var g = _groups.get(re); return Object.keys(g).reduce(function (groups, name) { groups[name] = result[g[name]]; return groups; }, Object.create(null)); } return _wrapRegExp.apply(this, arguments); }

// this will run at build time to evaluate what files are part of the workshop
// used with our codegen runner
var glob = require("glob");

var path = require("path");

var fs = require("fs"); // revisit if you decide exercises need multiple files?
// const fileInfo = [
//   undefined,
//   {
//     exercise: "import from exercise/index.js",
//     solution: "import from solution/index.js",
//     readme: "import from README.md",
//     title: "first line of README.md"
//   }
// ]
// function getTitle(readmePath) {
//   const contents = String(fs.readFileSync(readmePath));
//   const [firstLine] = contents.split(/\r?\n/);
//   const titleMatch = firstLine.match(/# (?<title>.*)$/);
//   return titleMatch?.groups?.title || "";
// }
// function getFiles() {
//   const cwd = process.cwd();
//   const fileList = glob.sync("**/*.+(js|html|md)");
//   const fileInfo = [];
//   for (const filePath of fileList) {
//     const [baseDir, folder] = filePath.split("/");
//     const isExerciseDirectory = /\d/.test(baseDir);
//     if (!isExerciseDirectory) continue;
//     const fullFilePath = path.join(cwd, filePath);
//     const { dir, name, ext } = path.parse(fullFilePath);
//     const number = Number(baseDir)
//     if (!(number in fileInfo)) {
//       fileInfo[number] = {}
//     }
//     // readme
//     if (ext === "md" || ext === "mdx") {
//       fileInfo[number].title = getTitle(fullFilePath)
//       fileInfo[number].readme = {
//         id: filePath,
//         fullFilePath,
//         filePath,
//         ext,
//         fileName: name,
//         isolatedPath: filePath.replace("src", "/isolated"),
//       };
//     }
//     // exercise
//     // solution
//   }
// }


function loadFiles() {
  var cwd = process.cwd();
  var fileInfo = glob // find files from predefined directories
  .sync("src/{exercise,solution,examples}/*.+(js|html|md|mdx)", {
    cwd: cwd
  }) // parse file details
  .map(function (filePath) {
    var _name$match, _name$match2;

    var fullFilePath = path.join(cwd, filePath);

    var _path$parse = path.parse(fullFilePath),
        dir = _path$parse.dir,
        name = _path$parse.name,
        ext = _path$parse.ext; // type can either come from the directory name (exercise, solution, examples)


    var type = path.basename(dir);
    var title; // or type can come from the file extension (readme)

    if (ext === ".md" || ext === ".mdx") {
      var _titleMatch$groups;

      type = "readme";
      var contents = String(fs.readFileSync(fullFilePath));

      var _contents$split = contents.split(/\r?\n/),
          _contents$split2 = (0, _slicedToArray2.default)(_contents$split, 1),
          firstLine = _contents$split2[0];

      var titleMatch = firstLine.match( /*#__PURE__*/_wrapRegExp(/# (.*)$/, {
        title: 1
      }));
      title = (titleMatch === null || titleMatch === void 0 ? void 0 : (_titleMatch$groups = titleMatch.groups) === null || _titleMatch$groups === void 0 ? void 0 : _titleMatch$groups.title) || "";
    } // exercise number for navigation


    var number = Number(((_name$match = name.match( /*#__PURE__*/_wrapRegExp(/(^[0-9]+)/, {
      num: 1
    }))) === null || _name$match === void 0 ? void 0 : _name$match.groups.num) || 0);
    var isExtraCredit = name.includes(".extra-");
    var extraCreditNumber = isExtraCredit ? Number(((_name$match2 = name.match(/(\d+$)/)) !== null && _name$match2 !== void 0 ? _name$match2 : [null])[0]) : 0; // todo: get title from file contents || file name?

    return {
      id: filePath,
      fullFilePath: fullFilePath,
      filePath: filePath,
      ext: ext,
      fileName: name,
      type: type,
      number: number,
      isolatedPath: filePath.replace("src", "/isolated"),
      title: title,
      isExtraCredit: isExtraCredit,
      extraCreditNumber: extraCreditNumber
    };
  });
  return fileInfo;
}

function getAppInfo() {
  var fileInfo = loadFiles(); // dynamically generate an import for each file
  // must return a string that will go thru the codegen.macro

  var imports = fileInfo.map(function (_ref) {
    var id = _ref.id,
        filePath = _ref.filePath,
        ext = _ref.ext;
    // use webpack loaders for non-JS files
    var loaders = "";

    if (ext === ".html") {
      loaders = "!raw-loader!";
    } else if (ext === ".md" || ext === ".mdx") {
      loaders = "!babel-loader!mdx-loader!";
    }

    var relativePath = filePath.replace("src/", "./"); // return import fn in a way we can use with React.Lazy
    // https://reactjs.org/docs/code-splitting.html#reactlazy

    return "\"".concat(id, "\": () => import(\"").concat(loaders).concat(relativePath, "\")");
  });
  return {
    fileInfo: fileInfo,
    imports: imports
  };
}

module.exports = {
  getAppInfo: getAppInfo
};